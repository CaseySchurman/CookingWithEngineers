{"changed":false,"filter":false,"title":"user.rb","tooltip":"/JuniorProject/app/models/user.rb","value":"################################################################################\n#Author: Johnathan Leuthold\n#Date: 11-25-2014\n#Modifications: 12-1-2014 Chad Greene\n#Description: The User model inherits from ActiveRecord which facilitates the \n#creation of the business object User, which is essentially a class whose \n#attributes are the columns derived from the plural database table 'users'. \n#ActiveRecord represents the persistence layer of the application.\n################################################################################\n#This model captures an individual 'User' object from the users table.\nclass User < ActiveRecord::Base\n  \n    #Relationships\n  has_many :recipes, dependent: :destroy\n  has_many :comments\n  has_many :ratings\n  has_many :active_follows, class_name: \"Follow\",\n                            foreign_key: \"follower_id\",\n                            dependent: :destroy\n  has_many :passive_follows, class_name: \"Follow\",\n                             foreign_key: \"followed_id\",\n                             dependent: :destroy\n  \n  has_many :following, through: :active_follows, source: :followed\n  has_many :followers, through: :passive_follows, source: :follower\n  \n    #Accessible attributes outside of those permitted in controller\n  attr_accessor :remember_token, :activation_token, :reset_token\n  \n    #Tells model to use BCrypt to create password digest\n  has_secure_password\n  \n    #before action callbacks\n  before_save :downcase_email\n  before_create :create_activation_digest\n\n    #Defines a regular expression for emails\n  EMAIL_REGEX = /\\A[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Za-z]{2,20}\\z/i\n  \n    #Validations\n  validates :username, presence: true, uniqueness: { case_sensitive: false }, \n                       length: 3..25\n  validates :email, presence: true, uniqueness: {case_sensitive: false }, \n                    length: 6..255, format: EMAIL_REGEX\n    ############################################################################\n    # has_secure_password enforces password on creation.  allow_blank allows\n    # blank password for updates\n    ############################################################################\n  validates :password, confirmation: true, length: 6..35, allow_blank: true\n    \n    ############################################################################\n    # Only checks password confirmation on creation since helper method\n    # verifies password_confirmation on updates\n    ############################################################################\n  validates :password_confirmation, presence: true, on: [:create]\n  \n  ##############################################################################\n  # Opperation done within Users singleton\n  ##############################################################################\n  class << self\n    ############################################################################\n    # Same authentication algorithm that BCrypt uses to hash the password.  \n    # Function will be used to hash reset and activation tokens\n    #\n    # Entry: token needs encrypting\n    #\n    #  Exit: attribute digest stored in database\n    ############################################################################\n    def digest(string)\n      cost = ActiveModel::SecurePassword.min_cost ? \n             BCrypt::Engine::MIN_COST : BCrypt::Engine.cost\n      BCrypt::Password.create(string, cost: cost)\n    end\n    \n    ############################################################################\n    # Creates a url safe base 64 token\n    #\n    # Entry: none\n    #\n    #  Exit: instance token generated\n    ############################################################################\n    def new_token\n      SecureRandom.urlsafe_base64\n    end\n  end\n  \n  ##############################################################################\n  # Sets up remember digest in database that signed cookies will use to \n  # authenticate a remembered user\n  #\n  # Entry: none\n  #\n  #  Exit: remember digest set\n  ##############################################################################\n  def remember\n    self.remember_token = User.new_token\n    update_attribute(:remember_digest, User.digest(remember_token))\n  end\n  \n  ##############################################################################\n  # Forgets user credentials\n  #\n  # Entry: none\n  #\n  #  Exit: remember digest set to nil\n  ##############################################################################\n  def forget\n    update_attribute(:remember_digest, nil)\n  end\n  \n  ##############################################################################\n  # Takes in an attribute to test and a token.  The attribute correspondes to a\n  # digest in the database.  The token should be a password for the hash.\n  #\n  # Entry: attribute is digest to look up\n  #        token is password for digest\n  #\n  #  Exit: returns true if token is a password for digest\n  ##############################################################################\n  def authenticated?(attribute, token)\n    digest = self.send(\"#{attribute}_digest\")\n    return false if digest.nil?\n    BCrypt::Password.new(digest).is_password?(token)\n  end\n  \n  ##############################################################################\n  # Activates a user account\n  #\n  # Entry: none\n  #\n  #  Exit: user account activated\n  ##############################################################################\n  def activate\n    update_attribute(:activated, true)\n  end\n  \n  ##############################################################################\n  # Sends an activation email to user\n  #\n  # Entry: none\n  #\n  #  Exit: Activation email sent to user\n  ##############################################################################\n  def send_activation_email\n    UserMailer.account_activation(self).deliver\n  end\n  \n  ##############################################################################\n  # Sets up a reset digest for a forgotten password\n  #\n  # Entry: none\n  #\n  #  Exit: reset digest set\n  ##############################################################################\n  def create_reset_digest\n    self.reset_token = User.new_token\n    update_columns(reset_digest: User.digest(reset_token),\n                   reset_sent_at: Time.zone.now)\n  end\n  \n  ##############################################################################\n  # Sends a password reset email to user\n  #\n  # Entry: none\n  #\n  #  Exit: Password reset email sent to user\n  ##############################################################################\n  def send_password_reset_email\n    UserMailer.password_reset(self).deliver\n  end\n  \n  ##############################################################################\n  # Allows a user to follow another user\n  #\n  # Entry: none\n  #\n  #  Exit: following user\n  ##############################################################################\n  def follow(other_user)\n    active_follows.create(followed_id: other_user.id)\n  end\n  \n  ##############################################################################\n  # Allows a user to unfollow a user they are currently following\n  #\n  # Entry: none\n  #\n  #  Exit: user unfollowed\n  ##############################################################################\n  def unfollow(other_user)\n    active_follows.find_by(followed_id: other_user.id).destroy\n  end\n  \n  ##############################################################################\n  # Determines if one user is following another\n  #\n  # Entry: other_user is a possible follow\n  #\n  #  Exit: returns true if user is following other_user\n  ##############################################################################\n  def following?(other_user)\n    following.include?(other_user)\n  end\n  \n  ##############################################################################\n  # Sets up the password reset link timer.  Expired links are not valid\n  #\n  # Entry: none\n  #\n  #  Exit: Password reset link timer set\n  ##############################################################################\n  def password_reset_expired?\n    reset_sent_at < 2.hours.ago\n  end\n  \n#PRIVATE########################################################################\nprivate\n  \n  ##############################################################################\n  # Sets email to all lowercase \n  #\n  # Entry: none\n  #\n  #  Exit: email lowercase\n  ##############################################################################\n  def downcase_email\n    self.email = email.downcase\n  end\n  \n  ##############################################################################\n  # Creates the user activation digest at registration\n  #\n  # Entry: none\n  #\n  #  Exit: activation digest set\n  ##############################################################################\n  def create_activation_digest\n    self.activation_token = User.new_token\n    self.activation_digest = User.digest(activation_token)\n  end\nend\n\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":36,"column":44},"end":{"row":36,"column":44},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1420925534000}